/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#include <array>
#include <gtest/gtest.h>

#include "DexInstruction.h"

static constexpr int kMaxSources = 5;

static void test_1_opcode(const char* name, uint16_t opcode) {
  DexInstruction insn(opcode);
  const std::string text = std::string("for opcode ") + name;
  const size_t src_count = insn.srcs_size();
  const bool has_dest = (insn.dests_size() > 0);
  const int dest_width = has_dest ? insn.dest_bit_width() : 0;
  const bool dest_is_src0 = insn.dest_is_src();

  // Populate source test values
  // We want to ensure that setting registers don't stomp each other
  // Create a unique bit pattern for each source based on its idx
  uint16_t dest_value = (1U << dest_width) - 1;
  uint16_t src_values[kMaxSources];
  for (int src_idx = 0; src_idx < src_count; src_idx++) {
    int src_width = insn.src_bit_width(src_idx);
    EXPECT_GE(src_width, 0) << text;
    uint16_t bits = (src_idx + 5);
    bits |= (bits << 4);
    bits |= (bits << 8);
    bits &= ((1U << src_width) - 1);
    src_values[src_idx] = bits;
  }

  // Set test values, and ensure nothing stomps anything else
  if (has_dest) {
    EXPECT_GE(dest_width, 0) << text;
    insn.set_dest(dest_value);
  }
  for (int i = 0; i < src_count; i++) {
    insn.set_src(i, src_values[i]);
  }
  // ensure nothing was stomped, except for what we expect to be stomped
  if (has_dest) {
    EXPECT_EQ(insn.dest(), dest_is_src0 ? src_values[0] : dest_value) << text;
  }
  for (int i = 0; i < src_count; i++) {
    EXPECT_EQ(insn.src(i), src_values[i]) << text;
  }

  // Ensure we can successfully set and then get the min and max register value
  if (has_dest) {
    uint16_t max = (1U << dest_width) - 1;
    insn.set_dest(0);
    EXPECT_EQ(insn.dest(), 0) << text;
    insn.set_dest(max);
    EXPECT_EQ(insn.dest(), max) << text;
  }
  for (int i = 0; i < src_count; i++) {
    uint16_t max = (1U << insn.src_bit_width(i)) - 1;
    insn.set_src(i, 0);
    EXPECT_EQ(insn.src(i), 0) << text;
    insn.set_src(i, max);
    EXPECT_EQ(insn.src(i), max) << text;
  }
}

#define TEST_1_OPCODE(code) test_1_opcode(#code, OPCODE_##code)

TEST(Registers, RoundTrip) {
  TEST_1_OPCODE(NOP);
  TEST_1_OPCODE(MOVE);
  TEST_1_OPCODE(MOVE_FROM16);
  TEST_1_OPCODE(MOVE_16);
  TEST_1_OPCODE(MOVE_WIDE);
  TEST_1_OPCODE(MOVE_WIDE_FROM16);
  TEST_1_OPCODE(MOVE_WIDE_16);
  TEST_1_OPCODE(MOVE_OBJECT);
  TEST_1_OPCODE(MOVE_OBJECT_FROM16);
  TEST_1_OPCODE(MOVE_OBJECT_16);
  TEST_1_OPCODE(MOVE_RESULT);
  TEST_1_OPCODE(MOVE_RESULT_WIDE);
  TEST_1_OPCODE(MOVE_RESULT_OBJECT);
  TEST_1_OPCODE(MOVE_EXCEPTION);
  TEST_1_OPCODE(RETURN_VOID);
  TEST_1_OPCODE(RETURN);
  TEST_1_OPCODE(RETURN_WIDE);
  TEST_1_OPCODE(RETURN_OBJECT);
  TEST_1_OPCODE(CONST_4);
  TEST_1_OPCODE(CONST_16);
  TEST_1_OPCODE(CONST);
  TEST_1_OPCODE(CONST_HIGH16);
  TEST_1_OPCODE(CONST_WIDE_16);
  TEST_1_OPCODE(CONST_WIDE_32);
  TEST_1_OPCODE(CONST_WIDE);
  TEST_1_OPCODE(CONST_WIDE_HIGH16);
  TEST_1_OPCODE(CONST_STRING);
  TEST_1_OPCODE(CONST_STRING_JUMBO);
  TEST_1_OPCODE(CONST_CLASS);
  TEST_1_OPCODE(MONITOR_ENTER);
  TEST_1_OPCODE(MONITOR_EXIT);
  TEST_1_OPCODE(CHECK_CAST);
  TEST_1_OPCODE(INSTANCE_OF);
  TEST_1_OPCODE(ARRAY_LENGTH);
  TEST_1_OPCODE(NEW_INSTANCE);
  TEST_1_OPCODE(NEW_ARRAY);
  TEST_1_OPCODE(FILLED_NEW_ARRAY);
  TEST_1_OPCODE(FILLED_NEW_ARRAY_RANGE);
  TEST_1_OPCODE(FILL_ARRAY_DATA);
  TEST_1_OPCODE(THROW);
  TEST_1_OPCODE(GOTO);
  TEST_1_OPCODE(GOTO_16);
  TEST_1_OPCODE(GOTO_32);
  TEST_1_OPCODE(PACKED_SWITCH);
  TEST_1_OPCODE(SPARSE_SWITCH);
  TEST_1_OPCODE(CMPL_FLOAT);
  TEST_1_OPCODE(CMPG_FLOAT);
  TEST_1_OPCODE(CMPL_DOUBLE);
  TEST_1_OPCODE(CMPG_DOUBLE);
  TEST_1_OPCODE(CMP_LONG);
  TEST_1_OPCODE(IF_EQ);
  TEST_1_OPCODE(IF_NE);
  TEST_1_OPCODE(IF_LT);
  TEST_1_OPCODE(IF_GE);
  TEST_1_OPCODE(IF_GT);
  TEST_1_OPCODE(IF_LE);
  TEST_1_OPCODE(IF_EQZ);
  TEST_1_OPCODE(IF_NEZ);
  TEST_1_OPCODE(IF_LTZ);
  TEST_1_OPCODE(IF_GEZ);
  TEST_1_OPCODE(IF_GTZ);
  TEST_1_OPCODE(IF_LEZ);

  TEST_1_OPCODE(AGET);
  TEST_1_OPCODE(AGET_WIDE);
  TEST_1_OPCODE(AGET_OBJECT);
  TEST_1_OPCODE(AGET_BOOLEAN);
  TEST_1_OPCODE(AGET_BYTE);
  TEST_1_OPCODE(AGET_CHAR);
  TEST_1_OPCODE(AGET_SHORT);
  TEST_1_OPCODE(APUT);
  TEST_1_OPCODE(APUT_WIDE);
  TEST_1_OPCODE(APUT_OBJECT);
  TEST_1_OPCODE(APUT_BOOLEAN);
  TEST_1_OPCODE(APUT_BYTE);
  TEST_1_OPCODE(APUT_CHAR);
  TEST_1_OPCODE(APUT_SHORT);

  TEST_1_OPCODE(IGET);
  TEST_1_OPCODE(IGET_WIDE);
  TEST_1_OPCODE(IGET_OBJECT);
  TEST_1_OPCODE(IGET_BOOLEAN);
  TEST_1_OPCODE(IGET_BYTE);
  TEST_1_OPCODE(IGET_CHAR);
  TEST_1_OPCODE(IGET_SHORT);
  TEST_1_OPCODE(IPUT);
  TEST_1_OPCODE(IPUT_WIDE);
  TEST_1_OPCODE(IPUT_OBJECT);
  TEST_1_OPCODE(IPUT_BOOLEAN);
  TEST_1_OPCODE(IPUT_BYTE);
  TEST_1_OPCODE(IPUT_CHAR);
  TEST_1_OPCODE(IPUT_SHORT);
  TEST_1_OPCODE(SGET);
  TEST_1_OPCODE(SGET_WIDE);
  TEST_1_OPCODE(SGET_OBJECT);
  TEST_1_OPCODE(SGET_BOOLEAN);
  TEST_1_OPCODE(SGET_BYTE);
  TEST_1_OPCODE(SGET_CHAR);
  TEST_1_OPCODE(SGET_SHORT);
  TEST_1_OPCODE(SPUT);
  TEST_1_OPCODE(SPUT_WIDE);
  TEST_1_OPCODE(SPUT_OBJECT);
  TEST_1_OPCODE(SPUT_BOOLEAN);
  TEST_1_OPCODE(SPUT_BYTE);
  TEST_1_OPCODE(SPUT_CHAR);
  TEST_1_OPCODE(SPUT_SHORT);
  TEST_1_OPCODE(INVOKE_VIRTUAL);
  TEST_1_OPCODE(INVOKE_SUPER);
  TEST_1_OPCODE(INVOKE_DIRECT);
  TEST_1_OPCODE(INVOKE_STATIC);
  TEST_1_OPCODE(INVOKE_INTERFACE);
  TEST_1_OPCODE(INVOKE_VIRTUAL_RANGE);
  TEST_1_OPCODE(INVOKE_SUPER_RANGE);
  TEST_1_OPCODE(INVOKE_DIRECT_RANGE);
  TEST_1_OPCODE(INVOKE_STATIC_RANGE);
  TEST_1_OPCODE(INVOKE_INTERFACE_RANGE);
  TEST_1_OPCODE(NEG_INT);
  TEST_1_OPCODE(NOT_INT);
  TEST_1_OPCODE(NEG_LONG);
  TEST_1_OPCODE(NOT_LONG);
  TEST_1_OPCODE(NEG_FLOAT);
  TEST_1_OPCODE(NEG_DOUBLE);
  TEST_1_OPCODE(INT_TO_LONG);
  TEST_1_OPCODE(INT_TO_FLOAT);
  TEST_1_OPCODE(INT_TO_DOUBLE);
  TEST_1_OPCODE(LONG_TO_INT);
  TEST_1_OPCODE(LONG_TO_FLOAT);
  TEST_1_OPCODE(LONG_TO_DOUBLE);
  TEST_1_OPCODE(FLOAT_TO_INT);
  TEST_1_OPCODE(FLOAT_TO_LONG);
  TEST_1_OPCODE(FLOAT_TO_DOUBLE);
  TEST_1_OPCODE(DOUBLE_TO_INT);
  TEST_1_OPCODE(DOUBLE_TO_LONG);
  TEST_1_OPCODE(DOUBLE_TO_FLOAT);
  TEST_1_OPCODE(INT_TO_BYTE);
  TEST_1_OPCODE(INT_TO_CHAR);
  TEST_1_OPCODE(INT_TO_SHORT);
  TEST_1_OPCODE(ADD_INT);
  TEST_1_OPCODE(SUB_INT);
  TEST_1_OPCODE(MUL_INT);
  TEST_1_OPCODE(DIV_INT);
  TEST_1_OPCODE(REM_INT);
  TEST_1_OPCODE(AND_INT);
  TEST_1_OPCODE(OR_INT);
  TEST_1_OPCODE(XOR_INT);
  TEST_1_OPCODE(SHL_INT);
  TEST_1_OPCODE(SHR_INT);
  TEST_1_OPCODE(USHR_INT);
  TEST_1_OPCODE(ADD_LONG);
  TEST_1_OPCODE(SUB_LONG);
  TEST_1_OPCODE(MUL_LONG);
  TEST_1_OPCODE(DIV_LONG);
  TEST_1_OPCODE(REM_LONG);
  TEST_1_OPCODE(AND_LONG);
  TEST_1_OPCODE(OR_LONG);
  TEST_1_OPCODE(XOR_LONG);
  TEST_1_OPCODE(SHL_LONG);
  TEST_1_OPCODE(SHR_LONG);
  TEST_1_OPCODE(USHR_LONG);
  TEST_1_OPCODE(ADD_FLOAT);
  TEST_1_OPCODE(SUB_FLOAT);
  TEST_1_OPCODE(MUL_FLOAT);
  TEST_1_OPCODE(DIV_FLOAT);
  TEST_1_OPCODE(REM_FLOAT);
  TEST_1_OPCODE(ADD_DOUBLE);
  TEST_1_OPCODE(SUB_DOUBLE);
  TEST_1_OPCODE(MUL_DOUBLE);
  TEST_1_OPCODE(DIV_DOUBLE);
  TEST_1_OPCODE(REM_DOUBLE);
  TEST_1_OPCODE(ADD_INT_2ADDR);
  TEST_1_OPCODE(SUB_INT_2ADDR);
  TEST_1_OPCODE(MUL_INT_2ADDR);
  TEST_1_OPCODE(DIV_INT_2ADDR);
  TEST_1_OPCODE(REM_INT_2ADDR);
  TEST_1_OPCODE(AND_INT_2ADDR);
  TEST_1_OPCODE(OR_INT_2ADDR);
  TEST_1_OPCODE(XOR_INT_2ADDR);
  TEST_1_OPCODE(SHL_INT_2ADDR);
  TEST_1_OPCODE(SHR_INT_2ADDR);
  TEST_1_OPCODE(USHR_INT_2ADDR);
  TEST_1_OPCODE(ADD_LONG_2ADDR);
  TEST_1_OPCODE(SUB_LONG_2ADDR);
  TEST_1_OPCODE(MUL_LONG_2ADDR);
  TEST_1_OPCODE(DIV_LONG_2ADDR);
  TEST_1_OPCODE(REM_LONG_2ADDR);
  TEST_1_OPCODE(AND_LONG_2ADDR);
  TEST_1_OPCODE(OR_LONG_2ADDR);
  TEST_1_OPCODE(XOR_LONG_2ADDR);
  TEST_1_OPCODE(SHL_LONG_2ADDR);
  TEST_1_OPCODE(SHR_LONG_2ADDR);
  TEST_1_OPCODE(USHR_LONG_2ADDR);
  TEST_1_OPCODE(ADD_FLOAT_2ADDR);
  TEST_1_OPCODE(SUB_FLOAT_2ADDR);
  TEST_1_OPCODE(MUL_FLOAT_2ADDR);
  TEST_1_OPCODE(DIV_FLOAT_2ADDR);
  TEST_1_OPCODE(REM_FLOAT_2ADDR);
  TEST_1_OPCODE(ADD_DOUBLE_2ADDR);
  TEST_1_OPCODE(SUB_DOUBLE_2ADDR);
  TEST_1_OPCODE(MUL_DOUBLE_2ADDR);
  TEST_1_OPCODE(DIV_DOUBLE_2ADDR);
  TEST_1_OPCODE(REM_DOUBLE_2ADDR);
  TEST_1_OPCODE(ADD_INT_LIT16);
  TEST_1_OPCODE(RSUB_INT);
  TEST_1_OPCODE(MUL_INT_LIT16);
  TEST_1_OPCODE(DIV_INT_LIT16);
  TEST_1_OPCODE(REM_INT_LIT16);
  TEST_1_OPCODE(AND_INT_LIT16);
  TEST_1_OPCODE(OR_INT_LIT16);
  TEST_1_OPCODE(XOR_INT_LIT16);
  TEST_1_OPCODE(ADD_INT_LIT8);
  TEST_1_OPCODE(RSUB_INT_LIT8);
  TEST_1_OPCODE(MUL_INT_LIT8);
  TEST_1_OPCODE(DIV_INT_LIT8);
  TEST_1_OPCODE(REM_INT_LIT8);
  TEST_1_OPCODE(AND_INT_LIT8);
  TEST_1_OPCODE(OR_INT_LIT8);
  TEST_1_OPCODE(XOR_INT_LIT8);
  TEST_1_OPCODE(SHL_INT_LIT8);
  TEST_1_OPCODE(SHR_INT_LIT8);
  TEST_1_OPCODE(USHR_INT_LIT8);
}
