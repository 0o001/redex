/**
 * Copyright (c) 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#include <array>
#include <gtest/gtest.h>

#include "Debug.h"
#include "androidfw/ResourceTypes.h"

std::string make_big_string(size_t len) {
  always_assert(len > 4);
  std::string result = "aa" + std::string(len - 4, 'x') + "zz";
  return result;
}

void assert_u16_string(std::u16string actual_str, std::string expected) {
  std::u16string expected_str(expected.begin(), expected.end());
  ASSERT_EQ(actual_str, expected_str);
}

TEST(ResStringPool, AppendToEmptyTable) {
  const size_t header_size = sizeof(android::ResStringPool_header);
  android::ResStringPool_header header = {
      {0x0001, header_size, header_size},
      0,
      0,
      android::ResStringPool_header::UTF8_FLAG |
          android::ResStringPool_header::SORTED_FLAG,
      0,
      0};
  android::ResStringPool pool((void*)&header, header_size, false);

  pool.appendString(android::String8("Hello, world"));
  auto big_string = make_big_string(300);
  auto big_chars = big_string.c_str();
  pool.appendString(android::String8(big_chars));
  pool.appendString(android::String8("€666"));
  pool.appendString(android::String8("banana banana"));
  android::Vector<char> v;
  pool.serialize(v);

  auto data = (void*)v.array();
  android::ResStringPool after(data, v.size(), false);

  // Ensure sort bit was cleared.
  auto flags = ((android::ResStringPool_header*)data)->flags;
  ASSERT_FALSE(flags & android::ResStringPool_header::SORTED_FLAG);

  size_t out_len;
  ASSERT_STREQ(after.string8At(0, &out_len), "Hello, world");
  ASSERT_EQ(out_len, 12);
  ASSERT_STREQ(after.string8At(1, &out_len), big_chars);
  ASSERT_EQ(out_len, 300);
  ASSERT_STREQ(after.string8At(2, &out_len), "€666");
  ASSERT_STREQ(after.string8At(3, &out_len), "banana banana");
}

TEST(ResStringPool, AppendToExistingUTF8) {
  // Chunk of just the ResStringPool, as generated by aapt2 (has 2 UTF8 strings)
  const std::array<uint8_t, 84> data{{
      0x01, 0x00, 0x1C, 0x00, 0x54, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
      0x0C, 0x0C, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x77, 0x6F, 0x72,
      0x6C, 0x64, 0x00, 0x1C, 0x1C, 0x72, 0x65, 0x73, 0x2F, 0x6C, 0x61, 0x79,
      0x6F, 0x75, 0x74, 0x2F, 0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x5F, 0x6C,
      0x61, 0x79, 0x6F, 0x75, 0x74, 0x2E, 0x78, 0x6D, 0x6C, 0x00, 0x00, 0x00}};
  android::ResStringPool pool(&data, data.size(), false);
  size_t out_len;
  ASSERT_STREQ(pool.string8At(0, &out_len), "Hello, world");

  pool.appendString(android::String8("this is another string"));
  android::Vector<char> v;
  pool.serialize(v);
  android::ResStringPool after((void*)v.array(), v.size(), false);

  // Make sure we still have the original two strings
  ASSERT_STREQ(after.string8At(0, &out_len), "Hello, world");
  ASSERT_EQ(out_len, 12);
  ASSERT_STREQ(after.string8At(1, &out_len), "res/layout/simple_layout.xml");
  ASSERT_EQ(out_len, 28);
  // And the one appended
  ASSERT_STREQ(after.string8At(2, &out_len), "this is another string");
  ASSERT_EQ(out_len, 22);
}

TEST(ResStringPool, AppendToExistingUTF16) {
  const std::array<uint8_t, 116> data{{
      0x01, 0x00, 0x1C, 0x00, 0x74, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00,
      0x1C, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
      0x05, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6C, 0x00, 0x6F, 0x00, 0x72, 0x00,
      0x00, 0x00, 0x05, 0x00, 0x64, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x65, 0x00,
      0x6E, 0x00, 0x00, 0x00, 0x02, 0x00, 0x69, 0x00, 0x64, 0x00, 0x00, 0x00,
      0x06, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x79, 0x00, 0x6F, 0x00, 0x75, 0x00,
      0x74, 0x00, 0x00, 0x00, 0x06, 0x00, 0x73, 0x00, 0x74, 0x00, 0x72, 0x00,
      0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x00, 0x00}};
  android::ResStringPool pool(&data, data.size(), false);
  ASSERT_TRUE(!pool.isUTF8());
  size_t out_len;
  auto s = pool.stringAt(0, &out_len);
  assert_u16_string(s, "color");
  ASSERT_EQ(out_len, 5);

  // Make sure the size encoding works for large values.
  auto big_string = make_big_string(35000);
  auto big_chars = big_string.c_str();
  pool.appendString(android::String8(big_chars));
  pool.appendString(android::String8("more more more"));
  android::Vector<char> v;
  pool.serialize(v);
  android::ResStringPool after((void*)v.array(), v.size(), false);

  assert_u16_string(after.stringAt(0, &out_len), "color");
  ASSERT_EQ(out_len, 5);
  assert_u16_string(after.stringAt(1, &out_len), "dimen");
  ASSERT_EQ(out_len, 5);
  assert_u16_string(after.stringAt(2, &out_len), "id");
  ASSERT_EQ(out_len, 2);
  assert_u16_string(after.stringAt(3, &out_len), "layout");
  ASSERT_EQ(out_len, 6);
  assert_u16_string(after.stringAt(4, &out_len), "string");
  ASSERT_EQ(out_len, 6);
  assert_u16_string(after.stringAt(5, &out_len), big_chars);
  ASSERT_EQ(out_len, 35000);
  assert_u16_string(after.stringAt(6, &out_len), "more more more");
  ASSERT_EQ(out_len, 14);
}
