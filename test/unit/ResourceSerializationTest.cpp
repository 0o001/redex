/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <array>
#include <fstream>
#include <gtest/gtest.h>

#include "ApkResources.h"
#include "Debug.h"
#include "RedexMappedFile.h"
#include "RedexResources.h"
#include "RedexTestUtils.h"
#include "SanitizersConfig.h"
#include "Util.h"
#include "androidfw/ResourceTypes.h"
#include "utils/Serialize.h"
#include "utils/Visitor.h"

namespace {
// Chunk of just the ResStringPool, as generated by aapt2 (has 2 UTF8 strings)
const std::array<uint8_t, 84> example_data_8{
    {0x01, 0x00, 0x1C, 0x00, 0x54, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
     0x0C, 0x0C, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x77, 0x6F, 0x72,
     0x6C, 0x64, 0x00, 0x1C, 0x1C, 0x72, 0x65, 0x73, 0x2F, 0x6C, 0x61, 0x79,
     0x6F, 0x75, 0x74, 0x2F, 0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x5F, 0x6C,
     0x61, 0x79, 0x6F, 0x75, 0x74, 0x2E, 0x78, 0x6D, 0x6C, 0x00, 0x00, 0x00}};

// Another aapt2 generated ResStringPool, encoded as UTF-16.
const std::array<uint8_t, 116> example_data_16{
    {0x01, 0x00, 0x1C, 0x00, 0x74, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00,
     0x1C, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
     0x05, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6C, 0x00, 0x6F, 0x00, 0x72, 0x00,
     0x00, 0x00, 0x05, 0x00, 0x64, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x65, 0x00,
     0x6E, 0x00, 0x00, 0x00, 0x02, 0x00, 0x69, 0x00, 0x64, 0x00, 0x00, 0x00,
     0x06, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x79, 0x00, 0x6F, 0x00, 0x75, 0x00,
     0x74, 0x00, 0x00, 0x00, 0x06, 0x00, 0x73, 0x00, 0x74, 0x00, 0x72, 0x00,
     0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x00, 0x00}};

std::string make_big_string(size_t len) {
  always_assert(len > 4);
  std::string result = "aa" + std::string(len - 4, 'x') + "zz";
  return result;
}

void assert_u16_string(const std::u16string& actual_str,
                       const std::string& expected) {
  std::u16string expected_str(expected.begin(), expected.end());
  ASSERT_EQ(actual_str, expected_str);
}

void assert_serialized_data(const void* original,
                            size_t length,
                            android::Vector<char>& serialized) {
  ASSERT_EQ(length, serialized.size());
  for (size_t i = 0; i < length; i++) {
    auto actual = *((const char*)original + i);
    ASSERT_EQ(actual, serialized[i]) << "Mismatch at offset " << i;
  }
}

void copy_file(const std::string& from, const std::string& to) {
  std::ifstream src_stream(from, std::ios::binary);
  std::ofstream dest_stream(to, std::ios::binary);
  dest_stream << src_stream.rdbuf();
}

bool are_files_equal(const std::string& p1, const std::string& p2) {
  std::ifstream f1(p1, std::ifstream::binary | std::ifstream::ate);
  std::ifstream f2(p2, std::ifstream::binary | std::ifstream::ate);
  always_assert_log(!f1.fail(), "Failed to read path %s", p1.c_str());
  always_assert_log(!f2.fail(), "Failed to read path %s", p2.c_str());
  if (f1.tellg() != f2.tellg()) {
    std::cerr << "File length mismatch. " << f1.tellg() << " != " << f2.tellg()
              << std::endl;
    return false;
  }
  f1.seekg(0, std::ifstream::beg);
  f2.seekg(0, std::ifstream::beg);
  return std::equal(std::istreambuf_iterator<char>(f1.rdbuf()),
                    std::istreambuf_iterator<char>(),
                    std::istreambuf_iterator<char>(f2.rdbuf()));
}
} // namespace

TEST(ResStringPool, AppendToEmptyTable) {
  const size_t header_size = sizeof(android::ResStringPool_header);
  android::ResStringPool_header header = {
      {htods(android::RES_STRING_POOL_TYPE), htods(header_size),
       htodl(header_size)},
      0,
      0,
      htodl(android::ResStringPool_header::UTF8_FLAG |
            android::ResStringPool_header::SORTED_FLAG),
      0,
      0};
  android::ResStringPool pool((void*)&header, header_size, false);

  pool.appendString(android::String8("Hello, world"));
  auto big_string = make_big_string(300);
  auto big_chars = big_string.c_str();
  pool.appendString(android::String8(big_chars));
  pool.appendString(android::String8("€666"));
  pool.appendString(android::String8("banana banana"));
  android::Vector<char> v;
  pool.serialize(v);

  auto data = (void*)v.array();
  android::ResStringPool after(data, v.size(), false);

  // Ensure sort bit was cleared.
  auto flags = dtohl(((android::ResStringPool_header*)data)->flags);
  ASSERT_FALSE(flags & android::ResStringPool_header::SORTED_FLAG);

  size_t out_len;
  ASSERT_STREQ(after.string8At(0, &out_len), "Hello, world");
  ASSERT_EQ(out_len, 12);
  ASSERT_STREQ(after.string8At(1, &out_len), big_chars);
  ASSERT_EQ(out_len, 300);
  ASSERT_STREQ(after.string8At(2, &out_len), "€666");
  ASSERT_STREQ(after.string8At(3, &out_len), "banana banana");
}

TEST(ResStringPool, AppendToExistingUTF8) {
  android::ResStringPool pool(&example_data_8, example_data_8.size(), false);
  size_t out_len;
  ASSERT_STREQ(pool.string8At(0, &out_len), "Hello, world");

  pool.appendString(android::String8("this is another string"));
  android::Vector<char> v;
  pool.serialize(v);
  android::ResStringPool after((void*)v.array(), v.size(), false);

  // Make sure we still have the original two strings
  ASSERT_STREQ(after.string8At(0, &out_len), "Hello, world");
  ASSERT_EQ(out_len, 12);
  ASSERT_STREQ(after.string8At(1, &out_len), "res/layout/simple_layout.xml");
  ASSERT_EQ(out_len, 28);
  // And the one appended
  ASSERT_STREQ(after.string8At(2, &out_len), "this is another string");
  ASSERT_EQ(out_len, 22);
}

TEST(ResStringPool, AppendToExistingUTF16) {
  android::ResStringPool pool(&example_data_16, example_data_16.size(), false);
  ASSERT_TRUE(!pool.isUTF8());
  size_t out_len;
  auto s = pool.stringAt(0, &out_len);
  assert_u16_string(s, "color");
  ASSERT_EQ(out_len, 5);

  // Make sure the size encoding works for large values.
  auto big_string = make_big_string(35000);
  auto big_chars = big_string.c_str();
  pool.appendString(android::String8(big_chars));
  pool.appendString(android::String8("more more more"));
  android::Vector<char> v;
  pool.serialize(v);
  android::ResStringPool after((void*)v.array(), v.size(), false);

  assert_u16_string(after.stringAt(0, &out_len), "color");
  ASSERT_EQ(out_len, 5);
  assert_u16_string(after.stringAt(1, &out_len), "dimen");
  ASSERT_EQ(out_len, 5);
  assert_u16_string(after.stringAt(2, &out_len), "id");
  ASSERT_EQ(out_len, 2);
  assert_u16_string(after.stringAt(3, &out_len), "layout");
  ASSERT_EQ(out_len, 6);
  assert_u16_string(after.stringAt(4, &out_len), "string");
  ASSERT_EQ(out_len, 6);
  assert_u16_string(after.stringAt(5, &out_len), big_chars);
  ASSERT_EQ(out_len, 35000);
  assert_u16_string(after.stringAt(6, &out_len), "more more more");
  ASSERT_EQ(out_len, 14);
}

TEST(ResStringPool, ReplaceStringsInXmlLayout) {
  // Given layout file should have a series of View subclasses in the XML, which
  // we will rename. Parse the resulting binary data, and make sure all tags are
  // right.
  auto f = RedexMappedFile::open(std::getenv("test_layout_path"));

  std::map<std::string, std::string> shortened_names;
  shortened_names.emplace("com.example.test.CustomViewGroup", "Z.a");
  shortened_names.emplace("com.example.test.CustomTextView", "Z.b");
  shortened_names.emplace("com.example.test.CustomButton", "Z.c");
  shortened_names.emplace("com.example.test.NotFound", "Z.d");

  android::Vector<char> serialized;
  size_t num_renamed = 0;
  ApkResources resources("");
  resources.replace_in_xml_string_pool(
      f.const_data(), f.size(), shortened_names, &serialized, &num_renamed);

  EXPECT_EQ(num_renamed, 3);
  android::ResXMLTree parser;
  parser.setTo(&serialized[0], serialized.size());
  EXPECT_EQ(android::NO_ERROR, parser.getError())
      << "Error parsing layout after rename";

  std::vector<std::string> expected_xml_tags;
  expected_xml_tags.push_back("Z.a");
  expected_xml_tags.push_back("TextView");
  expected_xml_tags.push_back("Z.b");
  expected_xml_tags.push_back("Z.c");
  expected_xml_tags.push_back("Button");

  size_t tag_count = 0;
  android::ResXMLParser::event_code_t type;
  do {
    type = parser.next();
    if (type == android::ResXMLParser::START_TAG) {
      EXPECT_LT(tag_count, 5);
      size_t len;
      android::String8 tag(parser.getElementName(&len));
      auto actual_chars = tag.string();
      auto expected_chars = expected_xml_tags[tag_count].c_str();
      EXPECT_STREQ(actual_chars, expected_chars);
      tag_count++;
    }
  } while (type != android::ResXMLParser::BAD_DOCUMENT &&
           type != android::ResXMLParser::END_DOCUMENT);
  EXPECT_EQ(tag_count, 5);
}

TEST(ResTable, AppendNewType) {
  auto src_file_path = std::getenv("test_arsc_path");
  auto tmp_dir = redex::make_tmp_dir("ResTable_AppendNewType%%%%%%%%");
  auto dest_file_path = tmp_dir.path + "/resources.arsc";
  copy_file(src_file_path, dest_file_path);

  auto src = RedexMappedFile::open(src_file_path);
  android::ResTable table;
  ASSERT_EQ(table.add(src.const_data(), src.size()), 0);
  // Read the number of original types.
  android::Vector<android::String8> original_type_names;
  table.getTypeNamesForPackage(0, &original_type_names);

  // Set up existing entry data to copy into a different type
  const uint8_t dest_type = 3;
  std::vector<uint32_t> source_ids;
  source_ids.push_back(0x7f010000);
  size_t num_ids = source_ids.size();
  android::Vector<android::Res_value> values;
  for (size_t i = 0; i < num_ids; i++) {
    android::Res_value val;
    table.getResource(source_ids[i], &val);
    values.push_back(val);
  }

  // Create a default looking ResTable_config
  android::ResTable_config default_config;
  memset(&default_config, 0, sizeof(android::ResTable_config));
  default_config.size = sizeof(android::ResTable_config);

  // Write a new .arsc file
  {
    ResourcesArscFile arsc_file(dest_file_path);
    std::vector<android::ResTable_config*> config_ptrs;
    config_ptrs.emplace_back(&default_config);
    arsc_file.define_type(0x7f, 3, "foo", config_ptrs, source_ids);
    arsc_file.serialize();
  }

  auto dest = RedexMappedFile::open(dest_file_path);
  android::ResTable round_trip;
  ASSERT_EQ(round_trip.add(dest.const_data(), dest.size()), 0);
  // Make sure entries exist in 0x7f03xxxx range
  for (size_t i = 0; i < num_ids; i++) {
    auto old_id = source_ids[i];
    auto new_id = 0x7f000000 | (dest_type << 16) | (old_id & 0xFFFF);
    android::Res_value expected = values[i];
    android::Res_value actual;
    round_trip.getResource(new_id, &actual);
    ASSERT_EQ(expected.dataType, actual.dataType);
    ASSERT_EQ(expected.data, actual.data);
  }

  // Sanity check values in their original location
  {
    android::Res_value out_value;
    round_trip.getResource(0x7f010000, &out_value);
    float val = android::complex_value(out_value.data);
    uint32_t unit = android::complex_unit(out_value.data, false);
    ASSERT_EQ((int)val, 10);
    ASSERT_EQ(unit, android::Res_value::COMPLEX_UNIT_DIP);
  }
  {
    android::Res_value out_value;
    round_trip.getResource(0x7f010001, &out_value);
    float val = android::complex_value(out_value.data);
    uint32_t unit = android::complex_unit(out_value.data, false);
    ASSERT_EQ((int)val, 20);
    ASSERT_EQ(unit, android::Res_value::COMPLEX_UNIT_DIP);
  }

  android::Vector<android::String8> type_names;
  round_trip.getTypeNamesForPackage(0, &type_names);
  ASSERT_EQ(type_names.size(), original_type_names.size() + 1);
}

TEST(ResStringPoolBuilder, TestPoolRebuild8) {
  android::ResStringPool pool(&example_data_8, example_data_8.size(), false);
  auto flags =
      (pool.isUTF8() ? android::ResStringPool_header::UTF8_FLAG : 0) |
      (pool.isSorted() ? android::ResStringPool_header::SORTED_FLAG : 0);
  auto pool_size = pool.size();

  arsc::ResStringPoolBuilder builder(flags);
  for (size_t i = 0; i < pool_size; i++) {
    size_t out_len;
    auto s = pool.string8At(i, &out_len);
    builder.add_string(s, out_len);
  }
  android::Vector<char> serialized;
  builder.serialize(&serialized);
  assert_serialized_data(&example_data_8, example_data_8.size(), serialized);
}

TEST(ResStringPoolBuilder, TestPoolRebuild16) {
  android::ResStringPool pool(&example_data_16, example_data_16.size(), false);
  auto flags =
      (pool.isUTF8() ? android::ResStringPool_header::UTF8_FLAG : 0) |
      (pool.isSorted() ? android::ResStringPool_header::SORTED_FLAG : 0);
  auto pool_size = pool.size();

  arsc::ResStringPoolBuilder builder(flags);
  for (size_t i = 0; i < pool_size; i++) {
    size_t out_len;
    auto s = pool.stringAt(i, &out_len);
    builder.add_string(s, out_len);
  }
  android::Vector<char> serialized;
  builder.serialize(&serialized);
  assert_serialized_data(&example_data_16, example_data_16.size(), serialized);
}

TEST(ResStringPoolBuilder, TestPoolRebuildStyle8) {
  const std::array<uint8_t, 232> data{
      {0x01, 0x00, 0x1c, 0x00, 0xe8, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
       0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
       0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
       0x41, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
       0x59, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x1c, 0x00, 0x00, 0x00, 0x11, 0x11, 0x41, 0x6e, 0x20, 0x75, 0x6e, 0x75,
       0x73, 0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x00,
       0x2a, 0x2a, 0x49, 0x20, 0x6c, 0x69, 0x6b, 0x65, 0x20, 0x61, 0x20, 0x66,
       0x69, 0x6e, 0x65, 0x20, 0x67, 0x6c, 0x61, 0x73, 0x73, 0x20, 0x6f, 0x66,
       0x20, 0x48, 0x32, 0x4f, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20,
       0x6d, 0x6f, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x21, 0x00, 0x0c, 0x0c, 0x48,
       0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x2e, 0x00,
       0x01, 0x01, 0x62, 0x00, 0x02, 0x02, 0x65, 0x6d, 0x00, 0x03, 0x03, 0x73,
       0x75, 0x62, 0x00, 0x03, 0x03, 0x73, 0x75, 0x70, 0x00, 0x00, 0x00, 0x00,
       0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
       0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
       0xff, 0xff, 0xff, 0xff, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
       0x0c, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
       0x18, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
       0xff, 0xff, 0xff, 0xff}};
  android::ResStringPool pool(&data, data.size(), false);
  auto flags =
      (pool.isUTF8() ? android::ResStringPool_header::UTF8_FLAG : 0) |
      (pool.isSorted() ? android::ResStringPool_header::SORTED_FLAG : 0);
  auto pool_size = pool.size();
  auto style_count = pool.styleCount();
  arsc::ResStringPoolBuilder builder(flags);
  for (size_t i = 0; i < pool_size; i++) {
    size_t out_len;
    auto s = pool.string8At(i, &out_len);
    if (i < style_count) {
      arsc::SpanVector vec;
      auto span = (android::ResStringPool_span*)pool.styleAt(i);
      arsc::collect_spans(span, &vec);
      builder.add_style(s, out_len, vec);
    } else {
      builder.add_string(s, out_len);
    }
  }
  EXPECT_EQ(pool.size(), builder.string_count());
  android::Vector<char> serialized;
  builder.serialize(&serialized);
  assert_serialized_data(&data, data.size(), serialized);
}

TEST(ResTableParse, TestUnknownPackageChunks) {
  // A table with one package, which has a fake chunk that is made up. The chunk
  // that is not known/recognized should just be copied as-is to the output.
  auto tmp_dir = redex::make_tmp_dir("ResTableParse%%%%%%%%");
  auto res_path = tmp_dir.path + "/resources.arsc";
  copy_file(std::getenv("resources_unknown_chunk"), res_path);
  ResourcesArscFile res_table(res_path);
  res_table.remove_unreferenced_strings();
  EXPECT_TRUE(
      are_files_equal(std::getenv("resources_unknown_chunk"), res_path));
}

TEST(Configs, TestConfigEquivalence) {
  android::ResTable_config default_config{};
  default_config.size = sizeof(android::ResTable_config);
  EXPECT_TRUE(arsc::are_configs_equivalent(&default_config, &default_config));
  android::ResTable_config land_config{};
  land_config.size = sizeof(android::ResTable_config);
  land_config.orientation = android::ResTable_config::ORIENTATION_LAND;
  EXPECT_FALSE(arsc::are_configs_equivalent(&default_config, &land_config));
  // Configs of different sizes (simulate some of our snapshots of older files)
  {
    struct SmallConfig {
      uint32_t a;
      uint32_t b;
      uint32_t c;
      uint32_t d;
    };
    SmallConfig small_config{};
    small_config.a = sizeof(SmallConfig);
    EXPECT_TRUE(arsc::are_configs_equivalent(
        &default_config, (android::ResTable_config*)&small_config));
  }
  {
    PACKED(struct BiggerConfig {
      android::ResTable_config config{};
      uint32_t a;
      uint32_t b;
      uint32_t c;
      uint32_t d;
    });
    BiggerConfig big_config{};
    big_config.config = default_config;
    big_config.config.size = sizeof(BiggerConfig);
    // Can't determine default values of newer versions we don't know about.
    EXPECT_FALSE(arsc::are_configs_equivalent(
        &default_config, (android::ResTable_config*)&big_config));
  }
}

TEST(ResTable, TestBuilderRoundTrip) {
  auto tmp_dir = redex::make_tmp_dir("ResTable%%%%%%%%");
  auto res_path = tmp_dir.path + "/resources.arsc";
  copy_file(std::getenv("test_arsc_path"), res_path);
  ResourcesArscFile res_table(res_path);
  res_table.serialize();
  EXPECT_TRUE(are_files_equal(std::getenv("test_arsc_path"), res_path));
}

namespace {
PACKED(struct EntryAndValue {
  android::ResTable_entry entry{};
  android::Res_value value{};
  EntryAndValue(uint32_t key_string_idx, uint8_t data_type, uint32_t data) {
    entry.size = sizeof(android::ResTable_entry);
    entry.key.index = key_string_idx;
    value.size = sizeof(android::Res_value);
    value.dataType = data_type;
    value.data = data;
  }
});

// For testing simplicity, a map that has two items in it.
PACKED(struct MapEntryAndValues {
  android::ResTable_map_entry entry{};
  android::ResTable_map item0{};
  android::ResTable_map item1{};
  MapEntryAndValues(uint32_t key_string_idx, uint32_t parent_ident) {
    entry.size = sizeof(android::ResTable_map_entry);
    entry.count = 2;
    entry.flags = android::ResTable_entry::FLAG_COMPLEX;
    entry.key.index = key_string_idx;
    entry.parent.ident = parent_ident;
    item0.value.size = sizeof(android::Res_value);
    item1.value.size = sizeof(android::Res_value);
  }
});
} // namespace

TEST(ResTable, ComputeSizes) {
  EntryAndValue simple(0, android::Res_value::TYPE_DIMENSION, 1000);
  EXPECT_EQ(arsc::compute_entry_value_length(&simple.entry),
            sizeof(EntryAndValue));
  MapEntryAndValues complex(1, 0);
  EXPECT_EQ(arsc::compute_entry_value_length(&complex.entry),
            sizeof(MapEntryAndValues));
}

namespace {
// A simple arsc file that many tests can get written against.
EntryAndValue e0(0, android::Res_value::TYPE_DIMENSION, 1000);
EntryAndValue e0_land(0, android::Res_value::TYPE_DIMENSION, 1001);
EntryAndValue e1(1, android::Res_value::TYPE_DIMENSION, 2000);
EntryAndValue e2(2, android::Res_value::TYPE_REFERENCE, 0x7f010001);
MapEntryAndValues style(3, 0);

// Create a default ResTable_config
android::ResTable_config default_config = {
    .size = sizeof(android::ResTable_config)};
// Create a landscape config
android::ResTable_config land_config = {
    .size = sizeof(android::ResTable_config),
    .orientation = android::ResTable_config::ORIENTATION_LAND};
// And a xxhdpi config
android::ResTable_config xxhdpi_config = {
    .size = sizeof(android::ResTable_config),
    .density = android::ResTable_config::DENSITY_XXHIGH};

void build_arsc_file_and_validate(
    const std::function<void(const std::string& temp_dir,
                             const std::string& arsc_path)>& callback) {
  auto pool_flags = android::ResStringPool_header::UTF8_FLAG;
  auto global_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);

  auto key_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  constexpr uint16_t ENTRY_COUNT = 4;
  const char* entry_names[ENTRY_COUNT] = {"first", "second", "third", "fourth"};
  for (uint16_t i = 0; i < ENTRY_COUNT; i++) {
    key_strings_builder->add_string(entry_names[i], strlen(entry_names[i]));
  }

  auto type_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  constexpr uint8_t TYPE_COUNT = 2;
  const char* type_names[2] = {"dimen", "style"};
  for (uint16_t i = 0; i < TYPE_COUNT; i++) {
    type_strings_builder->add_string(type_names[i], strlen(type_names[i]));
  }

  android::ResTable_package package_header{};
  package_header.id = 0x7f;
  memset(&package_header.name, 0, 128); // do I need this??
  package_header.name[0] = 'f';
  package_header.name[1] = 'o';
  package_header.name[2] = 'o';
  package_header.name[3] = '\0';
  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(key_strings_builder);
  package_builder->set_type_strings(type_strings_builder);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(global_strings_builder);
  table_builder->add_package(package_builder);

  // dimen
  std::vector<android::ResTable_config*> dimen_configs = {&default_config,
                                                          &land_config};
  // First res ID has entries in two different configs (this flag denotes that).
  // Subsequent two entries only have default config entries (hence zero).
  std::vector<uint32_t> dimen_flags = {
      android::ResTable_config::CONFIG_ORIENTATION, 0, 0};
  auto dimen_type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 1, dimen_configs, dimen_flags);
  package_builder->add_type(dimen_type_definer);

  dimen_type_definer->add(&default_config,
                          {(uint8_t*)&e0, sizeof(EntryAndValue)});
  dimen_type_definer->add(&land_config,
                          {(uint8_t*)&e0_land, sizeof(EntryAndValue)});
  dimen_type_definer->add(&default_config,
                          {(uint8_t*)&e1, sizeof(EntryAndValue)});
  dimen_type_definer->add_empty(&land_config);
  dimen_type_definer->add(&default_config,
                          {(uint8_t*)&e2, sizeof(EntryAndValue)});
  dimen_type_definer->add_empty(&land_config);

  // style
  std::vector<android::ResTable_config*> style_configs = {&xxhdpi_config};
  std::vector<uint32_t> style_flags = {
      android::ResTable_config::CONFIG_DENSITY};
  auto style_type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 2, style_configs, style_flags);
  package_builder->add_type(style_type_definer);

  style.item0.name.ident = 0x01010098; // android:textColor
  style.item0.value.dataType = android::Res_value::TYPE_INT_COLOR_RGB8;
  style.item0.value.data = 0xFF0000FF;

  style.item1.name.ident = 0x010100d4; // android:background
  style.item1.value.dataType = android::Res_value::TYPE_INT_COLOR_RGB8;
  style.item1.value.data = 0xFF00FF00;

  style_type_definer->add(&xxhdpi_config,
                          {(uint8_t*)&style, sizeof(MapEntryAndValues)});

  // Write to a file, give the callback the temp dir and file to validate
  // against.
  android::Vector<char> out;
  table_builder->serialize(&out);

  auto tmp_dir = redex::make_tmp_dir("ResTable_BuildNewTable%%%%%%%%");
  auto dest_file_path = tmp_dir.path + "/resources.arsc";
  std::cerr << "Writing new table to " << dest_file_path.c_str() << std::endl;
  std::ofstream fout(dest_file_path,
                     std::ios::out | std::ios::binary | std::ios::trunc);
  always_assert_log(fout.is_open(), "Could not open path %s for writing",
                    dest_file_path.c_str());
  fout.write(out.array(), out.size());
  fout.close();
  callback(tmp_dir.path, dest_file_path);
}

} // namespace

TEST(ResTable, BuildNewTable) {
  build_arsc_file_and_validate([&](const std::string& temp_dir,
                                   const std::string& arsc_path) {
    // Now, use unforked AOSP APIs to read out the data to make sure it matches
    // the stuff we put in.
    auto built_arsc_file = RedexMappedFile::open(arsc_path);
    android::ResTable built_arsc_table;
    EXPECT_EQ(built_arsc_table.add(built_arsc_file.const_data(),
                                   built_arsc_file.size()),
              0)
        << "Could not read built data!";

    // Look up resource IDs by the package, type and entry names, even though we
    // could just compute them ourselves (battle test the type, key strings
    // being accurate).
    auto get_id = [&](const char* fully_qualified_entry) {
      android::String16 e(fully_qualified_entry);
      return built_arsc_table.identifierForName(e.string(), e.size());
    };

    android::Res_value value;
    // 0x7f010000
    EXPECT_EQ(built_arsc_table.getResource(get_id("foo:dimen/first"), &value),
              0);
    EXPECT_EQ(e0.value.size, value.size);
    EXPECT_EQ(e0.value.dataType, value.dataType);
    EXPECT_EQ(e0.value.data, value.data);

    // 0x7f010001
    EXPECT_EQ(built_arsc_table.getResource(get_id("foo:dimen/second"), &value),
              0);
    EXPECT_EQ(e1.value.size, value.size);
    EXPECT_EQ(e1.value.dataType, value.dataType);
    EXPECT_EQ(e1.value.data, value.data);

    // 0x7f010002
    EXPECT_EQ(built_arsc_table.getResource(get_id("foo:dimen/third"), &value),
              0);
    EXPECT_EQ(e2.value.size, value.size);
    EXPECT_EQ(e2.value.dataType, value.dataType);
    EXPECT_EQ(e2.value.data, value.data);

    built_arsc_table.setParameters(&land_config);
    // Rotate to landscape should get different values for entry 0x7f010000
    built_arsc_table.getResource(get_id("foo:dimen/first"), &value);
    EXPECT_EQ(e0_land.value.size, value.size);
    EXPECT_EQ(e0_land.value.dataType, value.dataType);
    EXPECT_EQ(e0_land.value.data, value.data);

    // This one should resolve to same value as 0x7f010001 before
    EXPECT_EQ(built_arsc_table.getResource(get_id("foo:dimen/second"), &value),
              0);
    EXPECT_EQ(e1.value.size, value.size);
    EXPECT_EQ(e1.value.dataType, value.dataType);
    EXPECT_EQ(e1.value.data, value.data);

    // Crazy APIs for reading plurals, styles, etc.
    const android::ResTable::bag_entry* bag_entry;
    EXPECT_EQ(built_arsc_table.lockBag(get_id("foo:style/fourth"), &bag_entry),
              2);
    EXPECT_EQ(bag_entry->map.name.ident, style.item0.name.ident);
    EXPECT_EQ(bag_entry->map.value.dataType, style.item0.value.dataType);
    EXPECT_EQ(bag_entry->map.value.data, style.item0.value.data);
    bag_entry++;
    EXPECT_EQ(bag_entry->map.name.ident, style.item1.name.ident);
    EXPECT_EQ(bag_entry->map.value.dataType, style.item1.value.dataType);
    EXPECT_EQ(bag_entry->map.value.data, style.item1.value.data);
    bag_entry--;
    built_arsc_table.unlockBag(bag_entry);
  });
}
