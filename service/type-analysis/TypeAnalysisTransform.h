/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include "GlobalTypeAnalyzer.h"
#include "IRCode.h"
#include "LocalTypeAnalyzer.h"
#include "WholeProgramState.h"

namespace type_analyzer {

/**
 * Optimize the given code by:
 *   - removing dead nonnull assertions generated by Kotlin
 * (checkParameterIsNotNull/checkExpressionValueIsNotNull)
 */
class Transform final {
 public:
  using NullAssertionSet = std::unordered_set<DexMethodRef*>;
  struct Config {
    bool remove_redundant_null_checks{false};
    bool remove_kotlin_null_check_assertions{false};
    Config() {}
  };

  struct Stats {
    size_t null_check_removed{0};
    size_t kotlin_null_check_removed{0};

    Stats& operator+=(const Stats& that) {
      null_check_removed += that.null_check_removed;
      kotlin_null_check_removed += that.kotlin_null_check_removed;
      return *this;
    }

    bool is_empty() {
      return null_check_removed == 0 && kotlin_null_check_removed == 0;
    }

    void report(PassManager& mgr) const {
      mgr.incr_metric("kotlin_null_check_removed", kotlin_null_check_removed);
      TRACE(TYPE_TRANSFORM, 2, "TypeAnalysisTransform Stats:");
      TRACE(TYPE_TRANSFORM, 2, " null checks removed = %u", null_check_removed);
      TRACE(TYPE_TRANSFORM,
            2,
            " Kotlin null checks removed = %u",
            kotlin_null_check_removed);
    }
  };

  explicit Transform(Config config = Config()) : m_config(config) {}
  Stats apply(const type_analyzer::local::LocalTypeAnalyzer& lta,
              DexMethod* method,
              const NullAssertionSet& null_assertion_set);
  static void setup(NullAssertionSet& null_assertion_set);

 private:
  void apply_changes(IRCode*);

  bool can_optimize_null_checks(const DexMethod* method);

  const Config m_config;
  std::vector<std::pair<IRInstruction*, IRInstruction*>> m_replacements;
  std::vector<IRList::iterator> m_deletes;
};

} // namespace type_analyzer
