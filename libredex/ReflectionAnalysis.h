/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <memory>
#include <ostream>

#include <boost/optional.hpp>

#include "DexClass.h"
#include "IRInstruction.h"

namespace reflection {

namespace impl {

// Forward declarations.
class Analyzer;

} // namespace impl

/*
 * This analysis performs an intraprocedural constant propagation on a variety
 * of objects involved in reflective calls. It is aimed at exposing simple yet
 * common use cases of reflection.
 *
 * Example:
 *
 *   Bar bar_obj = new Bar();                          --> OBJECT(Bar)
 *   java.lang.Class foo_class = Foo.class;            --> CLASS(Foo)
 *   java.lang.Class bar_class = bar_obj.getClass();   --> CLASS(Bar)
 *   Field f = foo_class.getField("foo");              --> FIELD(Foo, "foo")
 *   Method m = bar_class.getMethod("bar");            --> METHOD(Bar, "bar")
 *   String s1 = f.getName();                          --> STRING("foo")
 *   String s2 = m.getName();                          --> STRING("bar")
 *   java.lang.Class baz_class = Class.forName("Baz"); --> CLASS(Baz)
 *
 * Note that the signature of a method is not tracked by the analysis. In the
 * example above, f may refer to any method named "foo" in the class Foo.
 */

/*
 * The first three are inputs of an reflecting operation.
 * The last three are output of an reflecting operation.
 */
/* clang-format off */
enum AbstractObjectKind {
  OBJECT, // An object instantiated locally, passed in as a param or read from
          // heap
  STRING, // A string literal
  CLASS,  // A java.lang.Class object
  FIELD,  // A java.lang.reflect.Field object
  METHOD, // A java.lang.reflect.Method object
};

/*
 * This only applies to AbstractObjectKind.CLASS.
 * By what kind of operation the class object is produced.
 */
enum ClassObjectSource {
  NON_REFLECTION, // Non-reflecting operations like param loading and get field.
  REFLECTION,     // Reflection operations like const-class or Class.forName().
  UNKNOWN,        // A joined value of a reflecting and non-reflectiong source.
  NOT_APPLICABLE, // AbstractObjectKind is not CLASS.
};

/* clang-format on */
struct AbstractObject {
  AbstractObjectKind kind;
  DexType* dex_type;
  DexString* dex_string;
  ClassObjectSource cls_source;

  // AbstractObject must be default constructible in order to be used as an
  // abstract value.
  AbstractObject() = default;

  explicit AbstractObject(DexString* s)
      : kind(STRING),
        dex_type(nullptr),
        dex_string(s),
        cls_source(NOT_APPLICABLE) {}

  explicit AbstractObject(DexType* t)
      : kind(OBJECT),
        dex_type(t),
        dex_string(nullptr),
        cls_source(NOT_APPLICABLE) {}

  AbstractObject(DexType* t, ClassObjectSource cls_source)
      : kind(CLASS), dex_type(t), dex_string(nullptr), cls_source(cls_source) {}

  AbstractObject(AbstractObjectKind k, DexType* t, DexString* s)
      : kind(k), dex_type(t), dex_string(s), cls_source(NOT_APPLICABLE) {
    always_assert(k == FIELD || k == METHOD);
  }
};

bool is_reflection_output(const AbstractObject& obj);

bool operator==(const AbstractObject& x, const AbstractObject& y);

bool operator!=(const AbstractObject& x, const AbstractObject& y);

using ReflectionSites = std::vector<
    std::pair<IRInstruction*, std::map<register_t, AbstractObject>>>;

class ReflectionAnalysis final {
 public:
  // If we don't declare a destructor for this class, a default destructor will
  // be generated by the compiler, which requires a complete definition of
  // sra_impl::Analyzer, thus causing a compilation error. Note that the
  // destructor's definition must be located after the definition of
  // sra_impl::Analyzer.
  ~ReflectionAnalysis();

  explicit ReflectionAnalysis(DexMethod* dex_method);

  const ReflectionSites get_reflection_sites() const;

  bool has_found_reflection() const;

  /*
   * Returns the abstract object (if any) referenced by the register at the
   * given instruction. Note that if the instruction overwrites the register,
   * the abstract object returned is the value held by the register *before*
   * that instruction is executed.
   */
  boost::optional<AbstractObject> get_abstract_object(
      size_t reg, IRInstruction* insn) const;

 private:
  const DexMethod* m_dex_method;
  std::unique_ptr<impl::Analyzer> m_analyzer;

  void get_reflection_site(
      const register_t reg,
      IRInstruction* insn,
      std::map<register_t, AbstractObject>* abstract_objects) const;
};

} // namespace reflection

std::ostream& operator<<(std::ostream& out,
                         const reflection::AbstractObject& x);
